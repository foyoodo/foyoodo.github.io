<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on Stay Humble</title><link>/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 设计模式 on Stay Humble</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><lastBuildDate>Mon, 25 May 2020 16:01:23 +0800</lastBuildDate><atom:link href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>抽象工厂模式 vs. 观察者模式</title><link>/post/abstract_factory-vs-observer/</link><pubDate>Mon, 25 May 2020 16:01:23 +0800</pubDate><guid>/post/abstract_factory-vs-observer/</guid><description>&lt;p>抽象工厂模式与观察者模式的相同点和不同点。&lt;/p></description></item><item><title>观察者模式</title><link>/post/observer-mode/</link><pubDate>Thu, 21 May 2020 14:59:11 +0800</pubDate><guid>/post/observer-mode/</guid><description>&lt;p>在此种模式中，一个目标对象管理所有依附于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常通过调用各个观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。&lt;/p></description></item><item><title>单例模式</title><link>/post/singleton-mode/</link><pubDate>Thu, 21 May 2020 10:38:54 +0800</pubDate><guid>/post/singleton-mode/</guid><description>&lt;p>单例模式，也叫单子模式。实现思路是：一个类能返回对象一个引用（永远是同一个）和一个获得该实例的方法（必须是&lt;strong>静态方法&lt;/strong>，通常使用 &lt;code>getInstance&lt;/code> 这个名称）。&lt;/p></description></item></channel></rss>