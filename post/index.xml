<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Stay Humble</title><link>/post/</link><description>Recent content in Posts on Stay Humble</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><lastBuildDate>Sun, 28 Mar 2021 19:21:37 +0800</lastBuildDate><atom:link href="/post/index.xml" rel="self" type="application/rss+xml"/><item><title>URL Schemes</title><link>/post/url-scheme/</link><pubDate>Sun, 28 Mar 2021 19:21:37 +0800</pubDate><guid>/post/url-scheme/</guid><description>&lt;p>这里收集了一些网上不太容易找到的，我日常用到的 URL Scheme。&lt;/p></description></item><item><title>SwiftUI 监听 keyboard 事件</title><link>/post/swiftui-keyboard-observer/</link><pubDate>Tue, 23 Feb 2021 08:59:11 +0800</pubDate><guid>/post/swiftui-keyboard-observer/</guid><description>&lt;p>通过 &lt;code>@ObservedObject&lt;/code> 进行依赖注入一个 keyboard 的处理类，监听系统的 &lt;code>Notification&lt;/code>。&lt;/p></description></item><item><title>图的数组（邻接矩阵）储存表示</title><link>/post/graph-adjacency-matrix/</link><pubDate>Sun, 19 Jul 2020 22:07:43 +0800</pubDate><guid>/post/graph-adjacency-matrix/</guid><description>&lt;p>本文完整实现了 &lt;strong>《数据结构（C语言版）》7.2.1 数组表示法&lt;/strong> 部分的代码。&lt;/p></description></item><item><title>抽象工厂模式 vs. 观察者模式</title><link>/post/abstract_factory-vs-observer/</link><pubDate>Mon, 25 May 2020 16:01:23 +0800</pubDate><guid>/post/abstract_factory-vs-observer/</guid><description>&lt;p>抽象工厂模式与观察者模式的相同点和不同点。&lt;/p></description></item><item><title>观察者模式</title><link>/post/observer-mode/</link><pubDate>Thu, 21 May 2020 14:59:11 +0800</pubDate><guid>/post/observer-mode/</guid><description>&lt;p>在此种模式中，一个目标对象管理所有依附于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常通过调用各个观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。&lt;/p></description></item><item><title>C++ 中的三法则</title><link>/post/three-rules/</link><pubDate>Thu, 21 May 2020 10:46:52 +0800</pubDate><guid>/post/three-rules/</guid><description/></item><item><title>单例模式</title><link>/post/singleton-mode/</link><pubDate>Thu, 21 May 2020 10:38:54 +0800</pubDate><guid>/post/singleton-mode/</guid><description>&lt;p>单例模式，也叫单子模式。实现思路是：一个类能返回对象一个引用（永远是同一个）和一个获得该实例的方法（必须是&lt;strong>静态方法&lt;/strong>，通常使用 &lt;code>getInstance&lt;/code> 这个名称）。&lt;/p></description></item><item><title>C++ 中的虚函数</title><link>/post/cpp-virtual-function/</link><pubDate>Thu, 21 May 2020 09:52:11 +0800</pubDate><guid>/post/cpp-virtual-function/</guid><description/></item></channel></rss>